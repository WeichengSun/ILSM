mat1<-network.or.subnet_mat1
mat2<-subnet_mat2
if(is.null(rownames(mat1)) | is.null(rownames(mat2))){
message("No rownames for matrices, so row IDs are used!")
rownames(mat1)<-paste0("mid_spe",seq=1:nrow(mat1))
rownames(mat2)<-paste0("mid_spe",seq=1:nrow(mat2))
matrow<-unique(c(rownames(mat1),rownames(mat2)))
}
#if(nrow(mat1)!=nrow(mat2))
#   message("re-check whether the row name of network.or.subnet_mat1 is corresponding to the row name of subnet_mat2!!!")
if(!is.null(rownames(mat1)) & !is.null(rownames(mat2)) & sum(is.na(rownames(mat1)))==0 & sum(is.na(rownames(mat2)))==0){
matrow<-unique(c(rownames(mat1),rownames(mat2)))
if(length(matrow)==0) stop("No connectors existed.")
}
else {stop("Make sure matrices either have no row names or have full row names. No NA!")}
mat_1<-matrix(0,length(matrow),ncol(mat1))
rownames(mat_1)<-matrow
mat_1[rownames(mat1),]<-mat1
#mat_1[mat_1>0]<-1
mat_2<-matrix(0,length(matrow),ncol(mat2))
rownames(mat_2)<-matrow
mat_2[rownames(mat2),]<-mat2
#mat_2[mat_2>0]<-1
mat1<-mat_1
mat2<-mat_2
}
else
stop("Please check the type of 'network.or.subnet_mat1' or 'subnet_mat2'")
#calculating the coid
logi<-(as.numeric(rowSums(mat1))*as.numeric(rowSums(mat2)))!=0
mat1<-mat1[logi,]
mat2<-mat2[logi,]
if(!weighted){
mat1[mat1>0]<-1
mat2[mat2>0]<-1
general_cor<-cor(as.numeric(rowSums(mat1)),as.numeric(rowSums(mat2)), method=method )
message(paste0("CoID= ",seq=round(general_cor,8),";"),"\n")
return(general_cor)
}
else{
subnet_mat1<-mat1
subnet_mat2<-mat2
logi<-(as.numeric(rowSums(subnet_mat1))*as.numeric(rowSums(subnet_mat2)))!=0
subnet_mat1<-subnet_mat1[logi,]
subnet_mat2<-subnet_mat2[logi,]
general_weight1<-apply(subnet_mat1,1,function(x){
if(sum(x)==0){return(0)}
else{x<-x[x!=0];
if (weight_type=="shannon"){return(-sum((x/sum(x))*(log(x/sum(x)))))}
else if (weight_type=="sum"){return(sum(x))}
else{ stop("weight_type should be 'shannon' or 'sum'")}
}
})
general_weight2<-apply(subnet_mat2,1,function(x){
if(sum(x)==0){return(0)}
else{x<-x[x!=0];
if (weight_type=="shannon"){return(-sum((x/sum(x))*(log(x/sum(x)))))}
else if (weight_type=="sum"){return(sum(x))}
else{ stop("weight_type should be 'shannon' or 'sum'")}
}
})
general_weight_cor<-cor(general_weight1,general_weight2,method=method)
message(paste0("CoID_weighted= ",seq=round(general_weight_cor,8),";"),"\n")
return(general_weight_cor)
}
}
coid(network.or.subnet_mat1,weighted=T)
devtools::load_all(".")
plot(PPH_Coltparkmeadow)
coid(PPH_Coltparkmeadow)
coid(PPH_Coltparkmeadow,weighted=T)
?coid
Net <- PPH_Coltparkmeadow
coid(Net)
set.seed(13)
E(Net)$weight<-runif(length(E(Net)),0.1,1)#random weights assigned
coid(Net,weighted=T)
coid(PPH_Coltparkmeadow)
coid(PPH_Coltparkmeadow,weighted=T)
data(PPH_Coltparkmeadow)
E(PPH_Coltparkmeadow)$weight<-runif(length(E(PPH_Coltparkmeadow)),0.1,1)
coid(PPH_Coltparkmeadow)
coid(PPH_Coltparkmeadow,weighted=T)
remove.packages("ILSM")
?coid
devtools::load_all(".")
?coid
data(PPH_Coltparkmeadow)
Net <- PPH_Coltparkmeadow
coid(Net)
set.seed(13)
E(Net)$weight<-runif(length(E(Net)),0.1,1)#random weights assigned
coid(Net,weighted=T)
knitr::include_graphics("../man/figure/motif_ILSM.png")
knitr::include_graphics("../man/figure/motif_ILSM.png")
knitr::include_graphics("../man/figure/motif_ILSM.png")
knitr::include_graphics("../man/figure/motif_ILSM.png")
knitr::include_graphics("../man/figure/motif_ILSM.png")
knitr::include_graphics("/man/figure/motif_ILSM.png")
knitr::include_graphics("./man/figure/motif_ILSM.png")
?null_model
null_model(PPH_Coltparkmeadow,1, null_type = "sauve")
tmp<-null_model(PPH_Coltparkmeadow,1, null_type = "sauve")
plot(tmp)
plot(tmp[[1]])
null_net<-null_model(PPH_Coltparkmeadow,100, null_type = "sauve")
coid_null<-sapply(null_res,coid)
coid_null<-sapply(null_net,coid)
hist(coid_null)
coid(PPH_Coltparkmeadow)-mean(coid_null)/sd(coid_null)
(coid(PPH_Coltparkmeadow)-mean(coid_null))/sd(coid_null)
cois_null<-sapply(null_net,cois)
(cois(PPH_Coltparkmeadow)-mean(cois_null))/sd(cois_null)
mean(cois_null)
hist(cois_null)
cois(PPH_Coltparkmeadow)
(cois(PPH_Coltparkmeadow)-mean(cois_null,na.rm = T))/sd(cois_null,na.rm = T)
sum(is.na(cois_null))
set.seed(12)
null_net<-null_model(PPH_Coltparkmeadow,100, null_type = "sauve")
coid_null<-sapply(null_net,coid)
(coid(PPH_Coltparkmeadow)-mean(coid_null))/sd(coid_null)
cois_null<-sapply(null_net,cois)
(cois(PPH_Coltparkmeadow)-mean(cois_null))/sd(cois_null)
coid_obs<-coid(PPH_Coltparkmeadow)
cois_obs<-cois(PPH_Coltparkmeadow)
(cois_obs-mean(cois_null))/sd(cois_null)
null_zp<-function(original_value,nullvalues){
z=(original_value-mean(nullvalues,na.rm=T))/sd(nullvalues,na.rm=T)
pless <- sum(original_value >= nullvalues, na.rm = TRUE)
pmore <- sum(original_value <= nullvalues, na.rm = TRUE)
p<-2 * pmin(pless, pmore)
p=pmin(1, (p + 1)/(length(nullvalues) + 1))
c(z=z,p=p)
}
null_zp(coid_obs,coid_null)
null_zp(cois_obs,cois_null)
null_net<-null_model(PPH_Coltparkmeadow,1000, null_type = "sub_both")# try "sub_both"
coid_null<-sapply(null_net,coid)
null_net<-null_model(PPH_Coltparkmeadow,1000, null_type = "sub_both")# try "sub_both"
?null_model
null_net<-null_model(PPH_Coltparkmeadow,1000, null_type = "both_sub")# try "both_sub"
null_net<-null_model(PPH_Coltparkmeadow,1000, null_type = "both_sub", sub_method="quasiswap")# try "both_sub"
coid_null<-sapply(null_net,coid)
cois_null<-sapply(null_net,cois)
null_zp<-function(original_value,nullvalues){
z=(original_value-mean(nullvalues,na.rm=T))/sd(nullvalues,na.rm=T)
pless <- sum(original_value >= nullvalues, na.rm = TRUE)
pmore <- sum(original_value <= nullvalues, na.rm = TRUE)
p<-2 * pmin(pless, pmore)
p=pmin(1, (p + 1)/(length(nullvalues) + 1))
c(z=z,p=p)
}
null_zp(coid_obs,coid_null)
null_zp(cois_obs,cois_null)
null_net<-null_model(PPH_Coltparkmeadow,100, null_type = "both_sub", sub_method="r00")# try "both_sub"
coid_null<-sapply(null_net,coid)
cois_null<-sapply(null_net,cois)
# calculate the Z value and P value.
null_zp<-function(original_value,nullvalues){
z=(original_value-mean(nullvalues,na.rm=T))/sd(nullvalues,na.rm=T)
pless <- sum(original_value >= nullvalues, na.rm = TRUE)
pmore <- sum(original_value <= nullvalues, na.rm = TRUE)
p<-2 * pmin(pless, pmore)
p=pmin(1, (p + 1)/(length(nullvalues) + 1))
c(z=z,p=p)
}
null_zp(coid_obs,coid_null)
null_zp(cois_obs,cois_null)
?null_model
devtools::load_all(".")
?ddom
?guild_overlap
?overlap_guild
PPH_Coltparkmeadow
devtools::load_all(".")
?betweenness
?closeness
library(ggplot2)
?scale_fill_hue
P<-read.csv(./data/PH.csv)
Q<-read.csv(./data/HP.csv)
getwd()
P<-read.csv("./data/PH.csv")
P<-read.csv("../data/PH.csv")
P<-read.csv("/data/PH.csv")
P<-read.csv("./data/PH.csv")
P<-read.csv("./data/HP.csv")
P
?read.csv
P<-read.csv("./data/HP.csv",row.names = 1)
View(P)
?igraph_from_matrices
P_mat<-read.csv("./data/HP.csv",row.names = 1)
Q_mat<-read.csv("./data/PP.csv",row.names = 1)
igraph_from_matrices(P_mat, Q_mat, weighted = F)
P_mat<-read.csv("./data/HP.csv",row.names = 1)
Q_mat<-read.csv("./data/PP.csv",row.names = 1)
igraph_from_matrices(P_mat, Q_mat, weighted = F)
mat1<-P_mat
mat2<-Q_mat
is.null(rownames(mat1)) | is.null(rownames(mat2))
!is.null(rownames(mat1)) & !is.null(rownames(mat2)) & sum(is.na(rownames(mat1)))==0 & sum(is.na(rownames(mat2)))==0
matrow<-unique(c(rownames(mat1),rownames(mat2)))
matrow
length(intersect(rownames(mat1),rownames(mat2)))==0
is.null(colnames(mat1))
spe<-unique(c(colnames(mat1),rownames(mat1),rownames(mat2),colnames(mat2)))
spe
MAT<-matrix(0,length(spe),length(spe))
dimnames(MAT)<-list(spe,spe)
MAT[colnames(mat1),rownames(mat1)]<-t(mat1)
# if(!isDirected1)
#    MAT[rownames(mat1),colnames(mat1)]<-mat1
MAT[rownames(mat2),colnames(mat2)]<-mat2
# if(!isDirected2)
#    MAT[colnames(mat2),rownames(mat2)]<-t(mat2)
NET<-graph_from_adjacency_matrix(MAT,weighted=weighted,mode="undirected")
weighted=F
# if(!isDirected2)
#    MAT[colnames(mat2),rownames(mat2)]<-t(mat2)
NET<-graph_from_adjacency_matrix(MAT,weighted=weighted,mode="undirected")
NET
spe
MAT
igraph_from_matrices(as.matrix(P_mat), as.matrix(Q_mat), weighted = F)
inherits(mat1)
inherits(mat2,c("matrix"))
inherits(mat2,c("data.frame"))
?if
?if
?if
!inherits(mat1,c("matrix"))
!inherits(mat1,c("matrix"))
inherits(mat1,c("matrix"))
igraph_from_matrices((P_mat), (Q_mat), weighted = F)
igraph_from_matrices<-function(mat1, mat2, weighted=F){
if(!inherits(mat1,c("matrix"))|!inherits(mat1,c("matrix"))){
stop("Please input matrices.")
}
if(is.null(rownames(mat1)) | is.null(rownames(mat2))){
message("Warning! Row IDs were set as rownames for matching connector nodes since no rownames are provided for the matrices")
rownames(mat1)<-paste0("b",seq=1:nrow(mat1))
rownames(mat2)<-paste0("b",seq=1:nrow(mat2))
matrow<-unique(c(rownames(mat1),rownames(mat2)))
}
if(!is.null(rownames(mat1)) & !is.null(rownames(mat2)) & sum(is.na(rownames(mat1)))==0 & sum(is.na(rownames(mat2)))==0)
{matrow<-unique(c(rownames(mat1),rownames(mat2)))}else
{stop("Please make sure the two matrices have appropriate row names. NA is not accepted.")}
if (length(intersect(rownames(mat1),rownames(mat2)))==0){stop("The two networks are not interconnected!")}
# mat_1<-matrix(0,length(matrow),ncol(mat1))
# rownames(mat_1)<-matrow
# colnames(mat_1)<-colnames(mat1)
# mat_1[rownames(mat1),]<-mat1
#
# mat_2<-matrix(0,length(matrow),ncol(mat2))
# rownames(mat_2)<-matrow
# colnames(mat_2)<-colnames(mat2)
# mat_2[rownames(mat2),]<-mat2
if(!weighted) {
mat1[mat1>0]<-1
mat2[mat2>0]<-1}
# mat1<-mat_1
# mat2<-mat_2
if(is.null(colnames(mat1)))
colnames(mat1)<-paste0("a",seq=1:ncol(mat1))
if(is.null(colnames(mat2)))
colnames(mat2)<-paste0("c",seq=1:ncol(mat2))
spe<-unique(c(colnames(mat1),rownames(mat1),rownames(mat2),colnames(mat2)))
MAT<-matrix(0,length(spe),length(spe))
dimnames(MAT)<-list(spe,spe)
MAT[colnames(mat1),rownames(mat1)]<-t(mat1)
# if(!isDirected1)
#    MAT[rownames(mat1),colnames(mat1)]<-mat1
MAT[rownames(mat2),colnames(mat2)]<-mat2
# if(!isDirected2)
#    MAT[colnames(mat2),rownames(mat2)]<-t(mat2)
NET<-graph_from_adjacency_matrix(MAT,weighted=weighted,mode="undirected")
V(NET)$name<-spe
levell<-rep(1,length(spe))
levell[spe%in%colnames(mat1)]<-0
# levell[spe%in%rownames(mat1)]<-1
levell[spe%in%colnames(mat2)]<-2
V(NET)$level<-levell
dd<-igraph::layout_with_sugiyama(NET,layers=V(NET)$level)$layout
dd[order(dd[dd[,2]==3,1]),1]<-seq(min(dd[,1]),max(dd[,1]),length.out=sum(dd[,2]==3))
dd[order(dd[dd[,2]==2,1])+sum(dd[,2]==3),1]<-seq(min(dd[,1]),max(dd[,1]),length.out=sum(dd[,2]==2))
dd[order(dd[dd[,2]==1,1])+sum(dd[,2]==3)+sum(dd[,2]==2),1]<-seq(min(dd[,1]),max(dd[,1]),length.out=sum(dd[,2]==1))
NET$layout<-dd
return(NET)
}
igraph_from_matrices((P_mat), (Q_mat), weighted = F)
PPH_Coltparkmeadow<-triigraph_from_matrices(as.matrix(P_mat), as.matrix(Q_mat), weighted = F)
PPH_Coltparkmeadow1<-igraph_from_matrices(as.matrix(P_mat), as.matrix(Q_mat), weighted = F)
igraph_from_matrices<-function(mat1, mat2, weighted=F){
if(!inherits(mat1,c("matrix"))|!inherits(mat1,c("matrix"))){
stop("Please input matrices.")
}
if(is.null(rownames(mat1)) | is.null(rownames(mat2))){
message("Warning! Row IDs were set as rownames for matching connector nodes since no rownames are provided for the matrices")
rownames(mat1)<-paste0("b",seq=1:nrow(mat1))
rownames(mat2)<-paste0("b",seq=1:nrow(mat2))
matrow<-unique(c(rownames(mat1),rownames(mat2)))
}
if(!is.null(rownames(mat1)) & !is.null(rownames(mat2)) & sum(is.na(rownames(mat1)))==0 & sum(is.na(rownames(mat2)))==0)
{matrow<-unique(c(rownames(mat1),rownames(mat2)))}else
{stop("Please make sure the two matrices have appropriate row names. NA is not accepted.")}
if (length(intersect(rownames(mat1),rownames(mat2)))==0){stop("The two networks are not interconnected!")}
# mat_1<-matrix(0,length(matrow),ncol(mat1))
# rownames(mat_1)<-matrow
# colnames(mat_1)<-colnames(mat1)
# mat_1[rownames(mat1),]<-mat1
#
# mat_2<-matrix(0,length(matrow),ncol(mat2))
# rownames(mat_2)<-matrow
# colnames(mat_2)<-colnames(mat2)
# mat_2[rownames(mat2),]<-mat2
if(!weighted) {
mat1[mat1>0]<-1
mat2[mat2>0]<-1}
# mat1<-mat_1
# mat2<-mat_2
if(is.null(colnames(mat1)))
colnames(mat1)<-paste0("a",seq=1:ncol(mat1))
if(is.null(colnames(mat2)))
colnames(mat2)<-paste0("c",seq=1:ncol(mat2))
spe<-unique(c(colnames(mat1),rownames(mat1),rownames(mat2),colnames(mat2)))
MAT<-matrix(0,length(spe),length(spe))
dimnames(MAT)<-list(spe,spe)
MAT[colnames(mat1),rownames(mat1)]<-t(mat1)
# if(!isDirected1)
#    MAT[rownames(mat1),colnames(mat1)]<-mat1
MAT[rownames(mat2),colnames(mat2)]<-mat2
# if(!isDirected2)
#    MAT[colnames(mat2),rownames(mat2)]<-t(mat2)
NET<-graph_from_adjacency_matrix(MAT,weighted=weighted,mode="max")
V(NET)$name<-spe
levell<-rep(1,length(spe))
levell[spe%in%colnames(mat1)]<-0
# levell[spe%in%rownames(mat1)]<-1
levell[spe%in%colnames(mat2)]<-2
V(NET)$level<-levell
dd<-igraph::layout_with_sugiyama(NET,layers=V(NET)$level)$layout
dd[order(dd[dd[,2]==3,1]),1]<-seq(min(dd[,1]),max(dd[,1]),length.out=sum(dd[,2]==3))
dd[order(dd[dd[,2]==2,1])+sum(dd[,2]==3),1]<-seq(min(dd[,1]),max(dd[,1]),length.out=sum(dd[,2]==2))
dd[order(dd[dd[,2]==1,1])+sum(dd[,2]==3)+sum(dd[,2]==2),1]<-seq(min(dd[,1]),max(dd[,1]),length.out=sum(dd[,2]==1))
NET$layout<-dd
return(NET)
}
PPH_Coltparkmeadow1<-igraph_from_matrices(as.matrix(P_mat), as.matrix(Q_mat), weighted = F)
PPH_Coltparkmeadow1
isomorphic(PPH_Coltparkmeadow1,PPH_Coltparkmeadow)
is.directed(PPH_Coltparkmeadow1)
is.directed(PPH_Coltparkmeadow)
plot(PPH_Coltparkmeadow)
as.undirected(PPH_Coltparkmeadow)
isomorphic(as.undirected(PPH_Coltparkmeadow),PPH_Coltparkmeadow1)
plot(as.undirected(PPH_Coltparkmeadow))#,PPH_Coltparkmeadow1)
plot(PPH_Coltparkmeadow1)
V(PPH_Coltparkmeadow1)
V(PPH_Coltparkmeadow1)$name
V(PPH_Coltparkmeadow)$name
rownames(P_mat)<-paste("pl",rownames(P_mat),sep="_")
rownames(Q_mat)<-paste("pl",rownames(Q_mat),sep="_")
View(P_mat)
colnames(P_mat)<-paste("po",colnames(P_mat),sep="_")
colnames(Q_mat)<-paste("he",colnames(Q_mat),sep="_")
View(P_mat)
PPH_Coltparkmeadow1<-igraph_from_matrices((P_mat, Q_mat, weighted = F)
PPH_Coltparkmeadow1<-igraph_from_matrices((P_mat, Q_mat, weighted = F)
PPH_Coltparkmeadow1<-igraph_from_matrices((P_mat,Q_mat,weighted = F)
PPH_Coltparkmeadow1<-igraph_from_matrices(P_mat,Q_mat,weighted = F)
P_mat<-as.matrix(read.csv("./data/HP.csv",row.names = 1))
Q_mat<-as.matrix(read.csv("./data/PP.csv",row.names = 1))
rownames(P_mat)<-paste("pl",rownames(P_mat),sep="_")
rownames(Q_mat)<-paste("pl",rownames(Q_mat),sep="_")
colnames(P_mat)<-paste("po",colnames(P_mat),sep="_")
colnames(Q_mat)<-paste("he",colnames(Q_mat),sep="_")
PPH_Coltparkmeadow1<-igraph_from_matrices(P_mat,Q_mat,weighted = F)
sum(V(PPH_Coltparkmeadow)$name==V(PPH_Coltparkmeadow1)$name)
sum(V(PPH_Coltparkmeadow)$name%in%V(PPH_Coltparkmeadow1)$name)
P_mat<-as.matrix(read.csv("./data/PP.csv",row.names = 1))
Q_mat<-as.matrix(read.csv("./data/HP.csv",row.names = 1))
rownames(P_mat)<-paste("pl",rownames(P_mat),sep="_")
rownames(Q_mat)<-paste("pl",rownames(Q_mat),sep="_")
colnames(P_mat)<-paste("po",colnames(P_mat),sep="_")
colnames(Q_mat)<-paste("he",colnames(Q_mat),sep="_")
PPH_Coltparkmeadow1<-igraph_from_matrices(P_mat,Q_mat,weighted = F)
sum(V(PPH_Coltparkmeadow)$name%in%V(PPH_Coltparkmeadow1)$name)
sum(V(PPH_Coltparkmeadow)$name==V(PPH_Coltparkmeadow1)$name)
V(PPH_Coltparkmeadow)$name
V(PPH_Coltparkmeadow1)$name
View(P_mat)
P_mat<-as.matrix(read.csv("./data/PP.csv",row.names = 1))
Q_mat<-as.matrix(read.csv("./data/HP.csv",row.names = 1))
View(P_mat)
P_mat<-as.matrix(read.csv("./data/PP.csv",row.names = 1))
View(P_mat)
?read.csv
P_mat<-as.matrix(read.csv("./data/PP.csv",row.names = 1,check.names=FALSE))
Q_mat<-as.matrix(read.csv("./data/HP.csv",row.names = 1,check.names=FALSE))
rownames(P_mat)<-paste("pl",rownames(P_mat),sep="_")
rownames(Q_mat)<-paste("pl",rownames(Q_mat),sep="_")
colnames(P_mat)<-paste("po",colnames(P_mat),sep="_")
colnames(Q_mat)<-paste("he",colnames(Q_mat),sep="_")
PPH_Coltparkmeadow1<-igraph_from_matrices(P_mat,Q_mat,weighted = F)
sum(V(PPH_Coltparkmeadow)$name==V(PPH_Coltparkmeadow1)$name)
sum(V(PPH_Coltparkmeadow)$name%in%V(PPH_Coltparkmeadow1)$name)
V(PPH_Coltparkmeadow)$name
V(PPH_Coltparkmeadow1)$name
isomorphic(as.undirected(PPH_Coltparkmeadow),PPH_Coltparkmeadow1)
PPH_Coltparkmeadow<-as_undirected(PPH_Coltparkmeadow)
plot( PPH_Coltparkmeadow)
( PPH_Coltparkmeadow)
saveRDS( PPH_Coltparkmeadow,file="./data/PPH_Coltparkmeadow.rda")
devtools::load_all(".")
?saveRDS
saveRDS(PPH_Coltparkmeadow,file="./data/PPH_Coltparkmeadow.rda")
devtools::load_all(".")
save(PPH_Coltparkmeadow,file="./data/PPH_Coltparkmeadow.rda")
devtools::load_all(".")
is_directed(PPH_Coltparkmeadow)
isomorphic((PPH_Coltparkmeadow),PPH_Coltparkmeadow1)
PPH_Coltparkmeadow<-PPH_Coltparkmeadow1
save(PPH_Coltparkmeadow,file="./data/PPH_Coltparkmeadow.rda")
devtools::load_all(".")
write.csv(P_mat,file="./data/PP1.csv")
write.csv(Q_mat,file="./data/HP1.csv")
P_mat<-as.matrix(read.csv("./data/PP.csv",row.names = 1,check.names=FALSE))
Q_mat<-as.matrix(read.csv("./data/HP.csv",row.names = 1,check.names=FALSE))
PPH_Coltparkmeadow1<-igraph_from_matrices(P_mat,Q_mat,weighted = F)
data("PPH_Coltparkmeadow")
isomorphic((PPH_Coltparkmeadow),PPH_Coltparkmeadow1)
View(P_mat)
P_mat<-as.matrix(read.csv("./data/PP1.csv",row.names = 1,check.names=FALSE))
Q_mat<-as.matrix(read.csv("./data/HP1.csv",row.names = 1,check.names=FALSE))
PPH_Coltparkmeadow1<-igraph_from_matrices(P_mat,Q_mat,weighted = F)
isomorphic((PPH_Coltparkmeadow),PPH_Coltparkmeadow1)
V(PPH_Coltparkmeadow)$name
V(PPH_Coltparkmeadow1)$name
trigraph_from_mat<-function(mat1, mat2, weighted=F){
if(!inherits(mat1,c("matrix"))|!inherits(mat1,c("matrix"))){
stop("Please input matrices.")
}
if(is.null(rownames(mat1)) | is.null(rownames(mat2))){
message("Warning! Row IDs were set as rownames for matching connector nodes since no rownames are provided for the matrices")
rownames(mat1)<-paste0("b",seq=1:nrow(mat1))
rownames(mat2)<-paste0("b",seq=1:nrow(mat2))
matrow<-unique(c(rownames(mat1),rownames(mat2)))
}
if(!is.null(rownames(mat1)) & !is.null(rownames(mat2)) & sum(is.na(rownames(mat1)))==0 & sum(is.na(rownames(mat2)))==0)
{matrow<-unique(c(rownames(mat1),rownames(mat2)))}else
{stop("Please make sure the two matrices have appropriate row names. NA is not accepted.")}
if (length(intersect(rownames(mat1),rownames(mat2)))==0){stop("The two networks are not interconnected!")}
# mat_1<-matrix(0,length(matrow),ncol(mat1))
# rownames(mat_1)<-matrow
# colnames(mat_1)<-colnames(mat1)
# mat_1[rownames(mat1),]<-mat1
#
# mat_2<-matrix(0,length(matrow),ncol(mat2))
# rownames(mat_2)<-matrow
# colnames(mat_2)<-colnames(mat2)
# mat_2[rownames(mat2),]<-mat2
if(!weighted) {
mat1[mat1>0]<-1
mat2[mat2>0]<-1}
# mat1<-mat_1
# mat2<-mat_2
if(is.null(colnames(mat1)))
colnames(mat1)<-paste0("a",seq=1:ncol(mat1))
if(is.null(colnames(mat2)))
colnames(mat2)<-paste0("c",seq=1:ncol(mat2))
spe<-unique(c(colnames(mat1),rownames(mat1),rownames(mat2),colnames(mat2)))
MAT<-matrix(0,length(spe),length(spe))
dimnames(MAT)<-list(spe,spe)
MAT[colnames(mat1),rownames(mat1)]<-t(mat1)
# if(!isDirected1)
#    MAT[rownames(mat1),colnames(mat1)]<-mat1
MAT[rownames(mat2),colnames(mat2)]<-mat2
# if(!isDirected2)
#    MAT[colnames(mat2),rownames(mat2)]<-t(mat2)
NET<-graph_from_adjacency_matrix(MAT,weighted=weighted,mode="max")
V(NET)$name<-spe
levell<-rep(1,length(spe))
levell[spe%in%colnames(mat1)]<-0
# levell[spe%in%rownames(mat1)]<-1
levell[spe%in%colnames(mat2)]<-2
V(NET)$level<-levell
dd<-igraph::layout_with_sugiyama(NET,layers=V(NET)$level)$layout
dd[order(dd[dd[,2]==3,1]),1]<-seq(min(dd[,1]),max(dd[,1]),length.out=sum(dd[,2]==3))
dd[order(dd[dd[,2]==2,1])+sum(dd[,2]==3),1]<-seq(min(dd[,1]),max(dd[,1]),length.out=sum(dd[,2]==2))
dd[order(dd[dd[,2]==1,1])+sum(dd[,2]==3)+sum(dd[,2]==2),1]<-seq(min(dd[,1]),max(dd[,1]),length.out=sum(dd[,2]==1))
NET$layout<-dd
return(NET)
}
devtools::load_all(".")
P_mat<-as.matrix(read.csv("./data/PP.csv",row.names = 1,check.names=FALSE))
Q_mat<-as.matrix(read.csv("./data/HP.csv",row.names = 1,check.names=FALSE))
PPH_Coltparkmeadow1<-trigraph_from_mat(P_mat,Q_mat,weighted = F)
coid(PPH_Coltparkmeadow1)
coid(P_mat,Q_mat)
coid(PPH_Coltparkmeadow1)
coid(P_mat,Q_mat)
poc(P_mat,Q_mat)
poc(PPH_Coltparkmeadow1)
?pc
?ddom
?ig_ddom
?pc
?pc
devtools::load_all(".")
?pc
